Learning a recursion based sorting technique called Merge Sort . It is a divide and conquer type of sort which works in O(nlog2(n)) .
Divide and conquer type er mul bishoy ta holo onek boro ekta problem thakbe . Oi problem tar direct solution ber kora tough . Ei jonne
amra oi boro problem ta ke chuto chuto subproblem e divide kore oi subproblem gula solve korbo . Erpore chuto subproblem theke pawa 
solution er vittite boro jei problem ta ache oita solve korbo . This technique is known as divide and conquer technique .

Merge sort er khetre array er element gula dui vaag e vaag hote thake jotokkhon na porjonto array er moddhe ekta element baki thake . 
Jokhon array te kebol ekta matro element baki thake tokhon oi array ta sorted ache . Erpore duita kore sorted array ek niye two pointer
approach use kore oi duita array ke sort kora hoy . Eivabe size 1 theke 2 , 4 , 8 ...... n  size er sorted array toiri hoy . Ekhane array
ta dui part e vaag houwar complexity holo O(log2(n)) . Ar vaag houwar pore sort hote hote boro array ta toiri houwar je prokriya oi process
er time complexity er value holo O(n) . Tahole full process tar complexity holo O(nlog2(n)) .
______________________________________________________________________________________________________________________________________________________
                                          [ Implementation Code For Merge Sort ]
ll n ;
const ll maxSize = 1e5+33 ;
ll vec[maxSize] ;
ll temp[maxSize] ;
void merge(ll l , ll r){
    ll mid = (l+r)/2 ; ll lptr = l ; ll rptr = mid+1 ; ll curr = l ;
    while(lptr<=mid and rptr <= r){
        if(vec[lptr]<vec[rptr]){
            temp[curr++] = vec[lptr++] ;
        }else{
            temp[curr++] = vec[rptr++] ;
        }
    }
    while(lptr<=mid) temp[curr++] = (vec[lptr++]) ;
    while(rptr<=r) temp[curr++] = (vec[rptr++]) ;
    for(int i = l ; i <= r ; i++) vec[i] = temp[i] ;
}

void mergeSort(ll l , ll r){
    if(l==r) return ; // Jodi l==r hoy tahole array er size 1 . Ar divide korar dorkar nei.
    ll mid = (l+r)/2 ;// Mid point where the array will be divided into two part .
    cout << "Need to sort (left part) : " << sesh ;
    for(int i = l ; i <= mid ; i++) cout << vec[i] << gap ;
    cout << sesh ;
    mergeSort(l,mid) ;
    cout << "Need to sort (right part) : " << sesh ;
    for(int i = mid+1 ; i <= r ; i++) cout << vec[i] << gap ;
    cout << sesh ;
    mergeSort(mid+1,r) ;
    cout << "Need to compare for merging : " << sesh ;
    for(int i = l ; i <= r ; i++) cout << vec[i] << gap ;
    cout << sesh ;
    merge(l,r) ;
    cout << "Values after merging : " << sesh ;
    for(int i = l ; i <= r ; i++) cout << vec[i] << gap ;
    cout << sesh ;
}

void IcpcDhakaRegionalist2025(){
    cin >> n ; tamjid(n) cin >> vec[i] ; mergeSort(0,n-1) ;
    cout << "Sorted Array : " << sesh ;
    for(int i = 0 ; i < n ; i++) cout << vec[i] << gap ;
    cout << sesh ;
}
______________________________________________________________________________________________________________________________________________________
                        [ C o u n t i n g   N u m b e r  o f  I n v e r s i o n s  U s i n g  M e r g e S o r t ]

Kuno ekta array teh jodi duita element x and y thake , x er value y er cheye boro hoy and x , y er age appear kore tahole oita oi array er jonne 
inversion hishebe count kora hoy . MergeSort er Algorithm er help niye khub shohoje ekta array er inversion count ber kora jay . 
Formal Definition of Inversion is :-  If for any index  i  <  j   and   a[i]  >  a[j]  this is called an inversion .

                                  { CODE FOR COUNTING INVERSION USING MERGESORT ALGORITHM }

ll sz ; 
const ll maxSize = 1e5+33 ;
ll vec[maxSize] ;
ll temp[maxSize] ;

ll merge(ll low, ll high) {
    ll mid = (low + high) >> 1; ll inversion = 0 ;
    ll ptr1 = low, ptr2 = mid + 1, idx = low;

    while (ptr1 <= mid && ptr2 <= high) {
        if (vec[ptr1] <= vec[ptr2]){
            temp[idx++] = vec[ptr1++] ;
        } else {
            temp[idx++] = vec[ptr2++] ; inversion += (mid-ptr1+1) ;
        }
    }
    while (ptr1 <= mid) {
        temp[idx++] = vec[ptr1++];
    }
    while (ptr2 <= high) {
        temp[idx++] = vec[ptr2++];
    }
    for (ll i = low; i <= high; ++i) vec[i] = temp[i];
    return inversion ;
}

ll mergeSort(ll low , ll high){
    if(low==high) return 0LL ;
    ll mid = ((low + high)>>1) ;
    ll a = mergeSort(low,mid) ; 
    ll b = mergeSort(mid+1,high) ;
    ll c = merge(low,high) ;
    return a + b + c ;
}


void IcpcDhakaRegionalist2025(){
    cin >> sz ; tamjid(sz) cin >> vec[i] ; ll ans = mergeSort(0,sz-1) ;
    cout << ans << sesh ;
}  
______________________________________________________________________________________________________________________________________________________
