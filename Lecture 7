_________________________________________________________________CSES PROBLEMSET TASK 1650 - Range Xor Queries __________________________________________________________
void IcpcDhakaRegionalist2025(){
    ll n , q ; cin >> n >> q ; vll vec(n) ; tamjid(n) cin >> vec[i] ;
    vll preCalc(n+1,0) ; tamjid(n) preCalc[i+1] ^= (preCalc[i] ^ vec[i]) ;
    while(q--){
        ll l , r ; cin >> l >> r ;
        cout << (preCalc[r] ^ preCalc[l-1]) << sesh ;
    }

Xor er special property er jonne difference array technique ta Range Xor queries er upore apply kora jay .
Summation er difference Array toiri korar shomoy amra jei kaaj ta kori ta holo left index er value add kore dei
and right+1 index e value minus kore dei . Fole prefixSum nile kuno poriborton hoy na . Xor er property holo :-
1)  0 ^ 0 =  0  ,  2)  0 ^ 1 = 1  ,  3) 1 ^ 0 = 1  ,  4)  1 ^ 1 = 0  .  
Common Form holo :-   1)  0 ^ x = x .   2) x ^ x = 0 . 
Tai ekhane alda operation korte hoy na x er value ta prefix xor theke remove korar jonne . 
Left index er sathe ^= x and right + 1 index er sathe ^= x kore dile automatic difference array er case ta handle hoye jay.

_________________________________________________________Codeforces 1398C --> Good SubArrays______________________________________________________________
Ei problem er moddhe bola hoise je amader ke bolte hobe array te koto gula emon subArray ache jader SubArray Sum == SubArray Length .
Formally  sum += arr[i] where low<=i<= high and sum == high - low + 1 hobe . Ei problem ta solve korar jonne amra partial sum er 
approach ta use korte pari . Jehetu  sum == length ,  PrefixSum[R] - PrefixSum[L-1] = R - ( L - 1 ) = R - L + 1 . 
Tarmane , PrefixSum[R] - PrefixSum[L] = R - L ==> PrefixSum[R] - R = PrefixSum[L] - L .
Eita ke generalize kore likha jay . PrefixSum[i] - i = 0 . Tar mane amra jodi ekta map e Frequency[PrefixSum[i]-i] store kore rakhi ,
tahole for every key answer er moddhe add hobe --->  (value * (value+1)) / 2 . Karon basic combinatoric theke amra jani n songkhok element
niye subArray toiri hote pare n * (n+1) / 2 ti .

Simple code for this problem written by Al-Shahriar-Tonmoy 

    ll n ; cin >> n ; string s ; cin >> s ; ll curSum = 0 ; 
    ll ans = 0 ; map<ll,ll> mp ; mp[curSum]++ ;
    for(int i = 0 ; i < n ; i++){ // Ekhaner moddhe ekta kore zero sum e -1 donate kortese ar baki value gula value-1 donate kortese.
        // Value-1 donate korar karon holo ekta kore value add houwar sathe sathe length o 1 kore bartese . Din seshe jodi runningSum
           er value 0 hoy tahole amader ke bujhte hobe je ekhon jei array ta amra pelam tar length ar summation er value shoman .
        curSum += (s[i]-'0') ; ans += mp[--curSum] ; mp[curSum]++ ;
    }
    cout << ans << sesh ;

Ekhane arekta observation ache . Jodi string er digit gula 0 <= digit <= 9 na hoye greater than zero hoto ( digit > 0 ) . Tahole good subArray er
moddhe kebol matro 1 gula e donate korto . Er cheye boro value useless hoye jeto . Kintu jehetu array teh 0 ache tar mane holo boro value gula ke
koyekta zero eshe neutrilize kore felte pare . Jemon     { 1 , 2 , 0 }     subArray teh 2 ke erpore 0 neutrilize kore feleche .

____________________________________________________Codeforces 1520D --> Same Differences______________________________________________________________
You are given an array a of n integers. Count the number of pairs of indices (i,j) such that i<j and aj−ai=j−i . Ager problem ta solve korar age
ei problem ta solve korle jei concept use hoy ei concept ta good subArrays problem ta solve korte use kora jabe .

    ll n ; cin >> n ; vll vec ; 
    tamjid(n){
        ll a ; cin >> a ; vec.pb(a-i) ;
    }
    nsort(vec) ; ll freq = 1LL ; ll ans = 0LL ;
    for(int i = 1 ; i < len(vec) ; i++){
        if(vec[i] == vec[i-1]){
            freq++ ;
        }else{
            ans += ((freq*(freq-1))>>1) ; freq = 1 ;
        }
    }
    ans += ((freq*(freq-1))>>1) ;
    cout << ans << endl ;

Ekhane muloto agei shobgula value theke eder index ke biyug kore dewa hoise . Jar fole amader ke ar question er condition niye chinta korte hocche na . 
Ekhon ekta map use kore kun element koybar kore ache ta count kore nicchi . Ar oi element er jonno koto gula emon pair toiri kora jabe ta answer e 
add kore kore shamner dike ogroshor hocchi. Ekhane i < j bole dewar karone (i,j) ekta pair hishabe count kortesi kintu (j,i) ke pair hishabe count 
kortesi na . Ar na hole pair songkha digun hoye jeto . Ekhane freq*(freq-1) / 2 kora hoise , kintu subArray er problem ta teh freq*(freq+1) /2 kora 
hoisilo . Duitar moddhe ei difference tar karon holo ekhon amra 1 ta element niye pair toiri korte parbo na . Ekta element ke shobshomoy hishab er
baire rakhte hobe . Ar SubArray er khetre single element o valid subArray toiri korto .

Jodi value ar index er moddhe ei rokom relation dewa kuno problem next e face kori tahole amader ke shob shomoy same index e thaka value er sathe
oi index er ekta relation toiri korar chesta korte hobe . Adnan Toky vai life e contest time e ei idea use kore atleast 4 ta problem solve korche.
_____________________________________________https://atcoder.jp/contests/abc125/tasks/abc125_c________________________________________________________

                                                  {  GCD On BlackBoard  }

ll n ; cin >> n ; vector<long long> vec(n+1,0) ;
    for(int i = 1 ; i <= n ; i++) cin >> vec[i] ;

    vector<long long> prefix_Gcd(n+2,0) , suffix_Gcd(n+2,0) ;

    for(int i = 1 ; i <= n ; i++){
        prefix_Gcd[i] = __gcd(prefix_Gcd[i-1],vec[i]) ;
    }

    for(int i = n ; i >= 1 ; i--){
        suffix_Gcd[i] = __gcd(suffix_Gcd[i+1],vec[i]) ;
    }

    ll gosagu = 0 ;
    for(int i = 1 ; i <= n ; i++) gosagu = __gcd(gosagu,vec[i]) ;

    for(int i = 1 ; i <= n ; i++){
        ll gcd = __gcd(prefix_Gcd[i-1],suffix_Gcd[i+1]) ;
        gosagu = max(gosagu,gcd) ;
    }

    cout << gosagu << sesh ;

Ekhane problem er moddhe bola hoise je , amake ekta array dewa hobe jar jekuno ekta element ami moner iccha moto change korte parbo . 
Highest possible gcd ami koto gain korte parbo . Ei problem ta solve korar upay hocche suffixGcd ar PrefixGcd niya all possible value 
er jonne check kora ashole koto baad dewa shomvob .
__________________________________________________________________________________________________________________________________________________
