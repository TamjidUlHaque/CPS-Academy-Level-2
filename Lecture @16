______________________________________________________Sliding Window Technique__________________________________________________________

Sliding window holo ekta technique jeita problem solve korte korte abishkar hoyeche . Eita kuno Data Structure ba algorithm na .
Ekhane duita pointer mile ekta window gothon kore k size er . Pore ei window er size er shoman element oi leftPointer theke right
pointer er moddhe probesh korle amra left and right ke ek ghor kore shamner dike egiye niye jai . Oi duita pointer diye toiri je
window ta move kore oita kei sliding window bole jar vitorer element gula onoboroto change hote thake .

_______________________________Find the maximum and minimum element for every k sized continuous subArrays_______________________________

    ll n , k ; cin >> n >> k ; vll vec(n) ; tamjid(n) cin >> vec[i] ;
    for(int i = 0 ; i < n-k+1 ; i++){
        ll minval = infinity ; ll maxval = aura ;
        for(int j = i ; j < i+k ; j++){
            minval = min(minval,vec[j]) ;
            maxval = max(maxval,vec[j]) ;
        }
        cout << "In window " << i+1 << gap << " : " << minval << gap << maxval << endl ;
      }
This is the brute force code for finding max and min element for each continuous subArrays of size k .
Ekhane worst case holo window er size n/2 . Tahole bairer loop cholbe n/2 times . Ar prottek bar bairer loop cholar jonne
vitorer loop cholbe n/2 times . Tar mane ei code er complexity holo O ( (n/2) * (n/2) ) is equivalent to O(n^2) .

-----------------------------------------------Optimized Code using Sliding window technique------------------------------------------

    ll n , k ; cin >> n >> k ; vll vec(n) ; tamjid(n) cin >> vec[i] ;
    multiset<ll> arr ; ll lptr = 0 ; ll rptr = 0 ;
    while(rptr-lptr<k) arr.insert(vec[rptr++]) ;
    while(rptr<n){
        if(rptr-lptr==k){
            cout << *arr.begin() << gap << *arr.rbegin() << sesh ;
            arr.erase(arr.find(vec[lptr++])) ;
        }else{
            arr.insert(vec[rptr++]) ;
        }
        if(rptr==n) cout << *arr.begin() << gap << *arr.rbegin() << sesh ;
    }

Ekhane amra multiset use kortesi array ta ke sorted obosthay pawar jonne + ekta kore position slide kortesi . 
Mane left pointer ekta kore index ke baire ber kore ditese ar right pointer ekta kore element ke array er vitore push
kortese . Multiset er karone sorting e logarithmic time complexity orjon kora shomvob hoyeche + O(1) ba constant time
complexity er maddhome smallest and largest element of the k sized subArray calculate kora shomvob hoyeche .

_______________________________CSES SLIDING WINDOW MEDIAN_____________https://cses.fi/problemset/task/1076/_______________________

void IcpcDhakaRegionalist2025(){
    ll n , k ; cin >> n >> k ; vll vec(n) ; tamjid(n) cin >> vec[i] ; 
    ordered_set<pair<ll,ll>> osat ; ll lptr = 0 ; ll rptr = 0 ;
    while(rptr-lptr<k) osat.insert({vec[rptr],rptr++}) ;
    while(rptr<n){
        cout << osat.find_by_order((k-1)/2)->F << gap ;
        osat.erase(osat.find({vec[lptr],lptr++})) ;
        osat.insert({vec[rptr],rptr++}) ;
    }
    cout << osat.find_by_order((k-1)/2)->F << sesh ;
}

This is the combined application of sliding window + policy based data structures . Ei problem er median ta bair korte giya koyekbar
wrong khaisi . Ei jinish ta kheyal rakhte hoibo . Median er value (k-1)/2 tomo index e thaka value . Arekta jinish sikhlam ,
PBDS er moddhe jokhon element gula re store koira rakha hoy tokhon Jodi less_equal ba greater_equal dei tahole oi ordered_sat
er upore osat.find() operation porichalona kora jabe na .

-----------------------------------------------------Variable Length Sliding Window----------------------------------------------------

Ekhon jei problem ta niye alochona kora hoise ta holo ekta array er moddhe shobcheye boro consecutive segment kunta jar moddhe kuno
duplicate value nai . Orthat maximum-sized SubArray who doesn't has any duplicate or every value is unique .
Ei problem ta solve korar jonne amra deque use korte pari jekhane variable length er window move korbe ar map use korte pari 
track rakhar jonne window size barate hobe naki komate hobe . Niche ei idea er upore based ekta problem solve kora holo .

_________________________https://cses.fi/problemset/task/1141/__________________________Playlist________________________________________

void IcpcDhakaRegionalist2025(){
    ll n ; cin >> n ; vll vec(n) ; tamjid(n) cin >> vec[i] ;
    map<ll,bool> presence ; deque<ll> window ; ll ans = 1 ;
    
    for(int i = 0 ; i < n ; i++){
        if(presence[vec[i]]){
            while(!window.empty()){
                ll curVal = window.front() ;
                window.pop_front() ;
                presence[curVal] = false ;
                if(curVal==vec[i]) break ;
            }
        }
        window.pb(vec[i]) ;         presence[vec[i]] = true ; 
        ll sz = window.size() ;     ans = max(ans,sz) ;
    }
    cout << ans << sesh ;
}
_______________________________________O_____________________________X____________________________O_______________________________________

---------------------------Ternary String---------------------------https://codeforces.com/problemset/problem/1354/B--------------------

This one is my previous solution . It is solved only using intuition and Use of c++ stl .

void giveMeMyGloryBack(){
    string s ; cin >> s ; vector<pair<char,int>> vec ; int ans = len(s)+2 ;
    for(int i = 0 ; i < len(s) ; i++){
        if(vec.empty() or vec.back().F != s[i]){
            vec.pb({s[i],1}) ;
        }else{
            vec.back().S++ ;
        }
    }
 
    for(int i = 1 ; i < len(vec)-1 ; i++){
        if(vec[i-1].F != vec[i+1].F) ans = min(ans,vec[i].S+2) ;
    }
    if(ans <= len(s)) cout << ans << endl ;
    else cout << 0 << endl ;
}
------------------------------Finding minimum length substring that contains a specific set of characters-----------------------------------

void IcpcDhakaRegionalist2025(){
    string s ; cin >> s ; ll n = len(s) ; ll answer = n ;
    if(count(all(s),'1') and count(all(s),'2') and count(all(s),'3')){
        
        deque<char> window ; map<char,int> freq ; queue<char> q ;
        for(auto &ch:s) q.push(ch) ;

        for(int i = 0 ; i < n ; i++){
            window.pb(s[i]) ; freq[s[i]]++ ; q.pop() ;
            if(freq.size()==3) break ;
        }

        while(true){
            answer = min(answer,(ll)window.size()) ;
            char curr = window.front() ;
            if(freq[curr]==1){
                while(!q.empty()){
                    char ch = q.front() ; freq[ch]++ ; 
                    window.pb(ch) ; q.pop() ;
                    if(ch==curr) break ;
                }
            }
            freq[curr]-- ; window.pop_front() ;
            if(freq[curr]==0) break ;
        }
        cout << answer << sesh ;
    }else{
        cout << 0 << sesh ;
    }
}
------------------------------Finding minimum length substring that contains a specific set of characters-----------------------------------

void IcpcDhakaRegionalist2025(){
    string s ; cin >> s ; ll n = len(s) ; ll answer = n ;
    if(count(all(s),'1') and count(all(s),'2') and count(all(s),'3')){
        ll lptr = 0 ; ll rptr = 0 ; map<char,ll> mp ;
        while(rptr<n){
            mp[s[rptr]]++ ; rptr++ ;
            while(mp['1'] and mp['2'] and mp['3']){
                answer = min(answer,rptr-lptr) ;
                mp[s[lptr]]-- ; lptr++ ;
            }
        }
        cout << answer << sesh ;
    }else{
        cout << 0 << sesh ;
    }
}

This is the two pointer approach for this solution .
