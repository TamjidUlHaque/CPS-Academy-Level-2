-------------------------------------------Maximum Points You Can Obtain From Cards--------------------LEETCODE 1423-----------------------------------------------------------------

class Solution {
    #define ll long long
public:
    int maxScore(vector<int>& cardPoints, int k) {
        int n = cardPoints.size() ; ll ans = 0 ; int minval = INT_MAX ;
        for(int i = 0 ; i < n ; i++) ans += cardPoints[i] ;
        int windowsize = n - k ; int currSum = 0 ;
        for(int i = 0 ; i < windowsize ; i++) currSum += cardPoints[i] ;

        minval = min(currSum,minval) ;
        for(int i = 0 ; i < n ; i++){
            currSum -= cardPoints[i] ;
            if(i+windowsize>=n) break ;
            currSum += cardPoints[i+windowsize] ;
            minval = min(currSum,minval) ;
        }
        return ans-minval ;
    }
};

Code that beats 100% people on the platform .

class Solution {
public:
    int maxScore(vector<int>& cardPoints, int k) {
        int n = cardPoints.size() ; int ans = 0 ; int result = INT_MIN ;
        int rptr = n-1 ; 
        for(int i = 0 ; i < k ; i++) ans += cardPoints[i] ;
        result = max(result,ans) ; --k ;
        while(k>=0){
            ans -= cardPoints[k--] ; ans += cardPoints[rptr--] ;
            result = max(ans,result) ;
        }
        return result ;
    }
};

-------------------------------------------------------Find all anagrams in a string--------------------------------LEETCODE 438------------------------------------------------------------
A string t will be an anagram of string s , if and only if t er shobgula alphabet re mon moto rearrange koira jodi s banani jay . 
Aro sohoj kothay jodi s ar t er moddhe shobgula alphabet er frequency count same thake taile ei duita string hoibo anagram .

_____________________________________________________Solution no 1 for this problem_____________________________________________________

class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        vector<int> ans ; multiset<char> sat , fixed ;
        if(s.size()<p.size()) return ans ;
        for(int i = 0 ; i < p.size() ; i++) fixed.insert(p[i]) ;
        for(int i = 0 ; i < s.size() ; i++){
            sat.insert(s[i]) ;
            if(sat.size()==fixed.size()){
                if(sat==fixed) ans.push_back(i-p.size()+1) ;
                sat.erase(sat.find(s[i-p.size()+1])) ;
            }
        }
        return ans ;
    }
};

_____________________________________________________Solution no 2 for this problem_____________________________________________________

class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        vector<int> ans ;
        if(s.size()<p.size()) return ans ;
        vector<int> freq(26,0) , count(26,0) ;
        for(int i = 0 ; i < p.size() ; i++) count[p[i]-'a']++ ;
        for(int i = 0 ; i < s.size() ; i++){
            freq[s[i]-'a']++ ;
            if(i>=(p.size()-1)){
                if(freq==count) ans.push_back(i-p.size()+1) ;
                freq[s[i-p.size()+1]-'a']-- ;
            }
        }
        return ans ;
    }
};

----------------------------------Solution 3 which is best because it is working in just O(n) complexity-----------------------------------

class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        int n = s.size() ; int k = p.size() ; vector<int> ans ; 
        if(k>n) return ans ; vector<int> alphabet(26,0),bornomala(26,0) ;
        for(auto ch:p) alphabet[ch-'a']++ ;
        for(int i = 0 ; i < k ; i++) bornomala[s[i]-'a']++ ;
        int matchCount = 0 ;
        for(int i = 0 ; i < 26 ; i++){
            if(alphabet[i]==bornomala[i]) matchCount++ ;
        }
        for(int i = 0 ; i < n ; i++){
            int x = s[i] - 'a' ; 
            if(matchCount==26) ans.push_back(i) ;
            if(alphabet[x]==bornomala[x]) matchCount-- ;
            bornomala[x]-- ;
            if(alphabet[x]==bornomala[x]) matchCount++ ;
            if(i+k>=n) break ;
            int y = s[i+k] - 'a' ;
            if(alphabet[y]==bornomala[y]) matchCount-- ;
            bornomala[y]++ ;
            if(alphabet[y]==bornomala[y]) matchCount++ ;
        }
        return ans ;
    }
};

--------------------The Smallest Window II-------------------https://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DSL_3_B-------------

void IcpcDhakaRegionalist2025(){
    int n , k ; cin >> n >> k ; int answer = INT_MAX ;
    vector<int> freq(k+1,0) ; int presence = 0 ;
    deque<int> window ;
    for(int i = 0 ; i < n ; i++){
        int x ; cin >> x ; window.pb(x) ;
        if(x<=k){
            freq[x]++ ; if(freq[x]==1) presence++ ;
        }
        while(presence==k){
            answer = min(answer,(int)window.size()) ;
            ll x = window.front() ; window.pop_front() ;
            if(x<=k){
                freq[x]-- ; if(freq[x]<1) presence-- ;
            }
        }
    }
    cout << (answer == INT_MAX ? 0 : answer) << sesh ;
}

---------------------------------------------Implementation in the class by Adnan Toky Vai-----------------------------------------

void IcpcDhakaRegionalist2025(){
    ll n , k ; cin >> n >> k ; queue<ll> q ; deque<ll> window ; 
    for(int i = 0 ; i < n ; i++){
        ll x ; cin >> x ; q.push(x) ;
    }
    vector<int> freq(k+1,0) ; ll presence = 0 ; 
    while(!q.empty()){
        ll x = q.front() ; q.pop() ; window.pb(x) ; 
        if(x<=k){
            freq[x]++ ; 
            if(freq[x]==1) presence++ ;
        }
        if(presence==k) break ;
    }
    if(presence<k){
        cout << 0 << endl ; return ;
    }

    int answer = (int)window.size() ;

    while(true){
        if(presence==k) answer = min(answer,(int)window.size()) ;

        ll y = window.front() ; window.pop_front() ;
        
        if(y>k) continue ;
        else{
            freq[y]-- ; 
            if(!freq[y]) {
                presence-- ; 
                while(!q.empty()){
                    ll x = q.front() ; q.pop() ; window.pb(x) ;
                    if(x<=k){
                        freq[x]++ ; if(freq[x]==1) presence++ ;
                    }
                    if(presence==k) break ;
                }
            }
        }

        if(presence != k) break ;
        
    }
    cout << answer << sesh ;
}

---------------------------------Distinct Values Subarrays II------------https://cses.fi/problemset/task/2428/-----------------------

void IcpcDhakaRegionalist2025(){
    ll n , k ; cin >> n >> k ; vll vec(n) ; tamjid(n) cin >> vec[i] ;
    ll ans = 0 ; map<ll,ll> mp ; ll lptr = 0 ; ll elem = 0 ; ll rptr = 0 ;

    while(rptr<n){
        mp[vec[rptr++]]++ ; elem++ ;
        if(len(mp)<=k) ans += elem ;
        else{
            while(len(mp)>k and lptr < rptr){
                if(mp[vec[lptr]]==1) mp.erase(vec[lptr]) ;
                else mp[vec[lptr]]-- ;
                lptr++ ; elem-- ;
            }
            ans += elem ;
        }
    }
    cout << ans << sesh ;
}


---------------------------------Distinct Values Subarrays---------------https://cses.fi/problemset/task/3420/-----------------------

void IcpcDhakaRegionalist2025(){
    ll n ; cin >> n ; vll vec(n) ; tamjid(n) cin >> vec[i] ;
    map<ll,ll> mp ; ll lptr = 0 , elem = 0 , rptr = 0 , ans = 0 ;

    while(rptr<n){
        mp[vec[rptr++]]++ ; elem++ ;
        if(len(mp)==elem) ans += elem ;
        else{
            while(len(mp)<elem and lptr < rptr){
                if(mp[vec[lptr]]==1) mp.erase(vec[lptr]) ;
                else mp[vec[lptr]]-- ;
                lptr++ ; elem-- ;
            }
            ans += elem ;
        }
    }
    cout << ans << sesh ;
}

---------------------------https://cses.fi/problemset/task/1076/-----------------------Sliding Window Median------------------------------

void IcpcDhakaRegionalist2025(){
    ll n , k ; cin >> n >> k ; vector<pair<ll,ll>> vec ;
    for(ll i = 0 ; i < n ; i++){
        ll x ; cin >> x ; vec.pb({x,i}) ;
    }
    ordered_set<pair<ll,ll>> osat ; 
    for(ll i = 0 ; i < n ; i++){
        osat.insert(vec[i]) ;
        if(i+1>=k){
            cout << (*osat.find_by_order((k-1)/2)).first << gap ;
            osat.erase(vec[i-k+1]) ;
        }
    }
}

____________________________Another Approach For this problem is maintaining two multisets and balancing them_____________________________

This approach uses two multisets to solve this problem . First multiset is storing the value of the smallest (k+1)/2 elements and 
the second multiset is storing the values of the largest n - (k+1)/2 elements . Value gula insert korar shomoy kheyal rakhte hobe 
je jeno small.rbegin() e thaka value er cheye current element boro hole jeno take second multiset e insert kori . Nahole jeno first
multiset er vitore insert kori . Ar .erase , .find ei shob opeation er shomoy reverse iterator use kora jabe na . .rbegin() er 
bodole prev(.end()) bebohar korte hobe . Eita kaaj kore na . Very Very Important .

void IcpcDhakaRegionalist2025(){
    ll n , k ; cin >> n >> k ; vll vec(n) ; tamjid(n) cin >> vec[i] ;
    multiset<ll> small , large ; 
    for(int i = 0 ; i < n ; i++){
        if(small.empty()){
            small.insert(vec[i]) ;
        }else if(*small.rbegin()<vec[i]){
            large.insert(vec[i]) ;
        }else{
            small.insert(vec[i]) ;
        }

        if(len(small)>len(large)+1){
            large.insert(*small.rbegin()) ; small.erase(prev(small.end())); ;
        }

        if(len(large)>len(small)){
            small.insert(*large.begin()) ; large.erase(large.begin()); ;
        }

        if(i+1>=k){
            cout << *small.rbegin() << gap ;
            if(small.find(vec[i-k+1]) != small.end()) small.erase(small.find(vec[i-k+1])) ;
            else large.erase(large.find(vec[i-k+1]));
        }

        if(len(small)>len(large)+1){
            large.insert(*small.rbegin()) ; small.erase(prev(small.end())); ;
        }

        if(len(large)>len(small)){
            small.insert(*large.begin()) ; large.erase(large.begin()); ;
        }
        
    }
}


______________________________________X________________________________O________________________________X_________________________________
