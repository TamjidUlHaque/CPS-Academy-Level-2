-------------------------------------------Maximum Points You Can Obtain From Cards--------------------LEETCODE 1423-----------------------------------------------------------------

class Solution {
    #define ll long long
public:
    int maxScore(vector<int>& cardPoints, int k) {
        int n = cardPoints.size() ; ll ans = 0 ; int minval = INT_MAX ;
        for(int i = 0 ; i < n ; i++) ans += cardPoints[i] ;
        int windowsize = n - k ; int currSum = 0 ;
        for(int i = 0 ; i < windowsize ; i++) currSum += cardPoints[i] ;

        minval = min(currSum,minval) ;
        for(int i = 0 ; i < n ; i++){
            currSum -= cardPoints[i] ;
            if(i+windowsize>=n) break ;
            currSum += cardPoints[i+windowsize] ;
            minval = min(currSum,minval) ;
        }
        return ans-minval ;
    }
};

Code that beats 100% people on the platform .

class Solution {
public:
    int maxScore(vector<int>& cardPoints, int k) {
        int n = cardPoints.size() ; int ans = 0 ; int result = INT_MIN ;
        int rptr = n-1 ; 
        for(int i = 0 ; i < k ; i++) ans += cardPoints[i] ;
        result = max(result,ans) ; --k ;
        while(k>=0){
            ans -= cardPoints[k--] ; ans += cardPoints[rptr--] ;
            result = max(ans,result) ;
        }
        return result ;
    }
};

-------------------------------------------------------Find all anagrams in a string--------------------------------LEETCODE 438------------------------------------------------------------
A string t will be an anagram of string s , if and only if t er shobgula alphabet re mon moto rearrange koira jodi s banani jay . 
Aro sohoj kothay jodi s ar t er moddhe shobgula alphabet er frequency count same thake taile ei duita string hoibo anagram .

_____________________________________________________Solution no 1 for this problem_____________________________________________________

class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        vector<int> ans ; multiset<char> sat , fixed ;
        if(s.size()<p.size()) return ans ;
        for(int i = 0 ; i < p.size() ; i++) fixed.insert(p[i]) ;
        for(int i = 0 ; i < s.size() ; i++){
            sat.insert(s[i]) ;
            if(sat.size()==fixed.size()){
                if(sat==fixed) ans.push_back(i-p.size()+1) ;
                sat.erase(sat.find(s[i-p.size()+1])) ;
            }
        }
        return ans ;
    }
};

_____________________________________________________Solution no 2 for this problem_____________________________________________________

class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        vector<int> ans ;
        if(s.size()<p.size()) return ans ;
        vector<int> freq(26,0) , count(26,0) ;
        for(int i = 0 ; i < p.size() ; i++) count[p[i]-'a']++ ;
        for(int i = 0 ; i < s.size() ; i++){
            freq[s[i]-'a']++ ;
            if(i>=(p.size()-1)){
                if(freq==count) ans.push_back(i-p.size()+1) ;
                freq[s[i-p.size()+1]-'a']-- ;
            }
        }
        return ans ;
    }
};

----------------------------------Solution 3 which is best because it is working in just O(n) complexity-----------------------------------

class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        int n = s.size() ; int k = p.size() ; vector<int> ans ; 
        if(k>n) return ans ; vector<int> alphabet(26,0),bornomala(26,0) ;
        for(auto ch:p) alphabet[ch-'a']++ ;
        for(int i = 0 ; i < k ; i++) bornomala[s[i]-'a']++ ;
        int matchCount = 0 ;
        for(int i = 0 ; i < 26 ; i++){
            if(alphabet[i]==bornomala[i]) matchCount++ ;
        }
        for(int i = 0 ; i < n ; i++){
            int x = s[i] - 'a' ; 
            if(matchCount==26) ans.push_back(i) ;
            if(alphabet[x]==bornomala[x]) matchCount-- ;
            bornomala[x]-- ;
            if(alphabet[x]==bornomala[x]) matchCount++ ;
            if(i+k>=n) break ;
            int y = s[i+k] - 'a' ;
            if(alphabet[y]==bornomala[y]) matchCount-- ;
            bornomala[y]++ ;
            if(alphabet[y]==bornomala[y]) matchCount++ ;
        }
        return ans ;
    }
};

--------------------The Smallest Window II-------------------https://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DSL_3_B-------------

void IcpcDhakaRegionalist2025(){
    int n , k ; cin >> n >> k ; int answer = INT_MAX ;
    vector<int> freq(k+1,0) ; int presence = 0 ;
    deque<int> window ;
    for(int i = 0 ; i < n ; i++){
        int x ; cin >> x ; window.pb(x) ;
        if(x<=k){
            freq[x]++ ; if(freq[x]==1) presence++ ;
        }
        while(presence==k){
            answer = min(answer,(int)window.size()) ;
            ll x = window.front() ; window.pop_front() ;
            if(x<=k){
                freq[x]-- ; if(freq[x]<1) presence-- ;
            }
        }
    }
    cout << (answer == INT_MAX ? 0 : answer) << sesh ;
}

______________________________________X________________________________O________________________________X_________________________________
